# verilog_basics
 This repository includes basic RTL sources written in Verilog-HDL
 
# n_bit_multiplier
 This module is a recursive implementation of the n-bit unsigned binary multiplier. The number of bits (n) of the multipliers can be managed by the BIT_DEPTH parameter. So, the module is reconfigurable according to the bit depth of multipliers before synthesis. Therefore, the utilization of the sources changes with the parameter BIT_DEPTH. 
 
 The module is called recursively inside the generate block. The first call starts with BIT_DEPTH configured in the parameters then it calls itself BIT_DEPTH/2 bit depth each time until BIT_DEPTH=2. Therefore, it all starts with 2-bit x 2-bit multiplication by using half adders. For example in an 8-bit multiplier, initially 4-bit multiplier is generated by 2-bit x 2-bit multipliers, and then an 8-bit multiplier is generated by using 4-bitx4-bit multipliers.
 
 <img width="426" alt="util32" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/440c7cbc-980e-4fbb-ac62-fb43201e29ea">

 
 <img width="425" alt="util16" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/472157b1-cd0c-4dd8-8b3e-fe5944b5fb3d">

 In the n_bit_multiplier/src/n_bit_mul.v, it can be seen that bit depth is defined as 32. Above you can see the utilization of the sources for the part xc7z020clg484-1.

<img width="1413" alt="sim32" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/200afa08-3354-4ad1-9397-1ca96b139159">

There is a multiplication simulation of the 32-bit configuration of the module. In the simulation, (2-4-8-16-32)-bit binary number multiplications are tested for two examples each bit depth.

To run the simulation with the Python script named [test.py](https://github.com/oktayogutcu/verilog_basics/blob/main/n_bit_multiplier/test.py), Icarus Verilog for MAC from this [link](https://formulae.brew.sh/formula/icarus-verilog) and for visualization GTKWave from this [link](https://gtkwave.sourceforge.net/.) has to be downloaded.

# 16_bit_multiplier

A non-recursive version of n_bit_multiplier is added for comparison of utilization and functionality.

<img width="371" alt="util" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/21569be1-b706-4a7d-8bc2-5adfacb11013">

It can be seen from the utilization result above, they have used the same amount of sources.

<img width="1237" alt="sim" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/6ebc45fb-70a6-47be-a9d9-22fa4dd75ed2">

Also, the module retains its functionality when comparing the recursive one.


# cocotb_example

Cocotb, which stands for Coroutine-based Co-simulation Testbench, is a Python library designed for validating hardware designs crafted in hardware description languages such as Verilog or VHDL. Cocotb seamlessly integrates with simulators, offering advanced capabilities for generating stimuli, validating results, and analyzing functional coverage. This enhances the overall hardware design verification procedure, making it more robust and efficient. Further explanation is [here](https://docs.cocotb.org/en/stable/index.html)

The latest version of Python cocotb library is recommended.
1) Python 3.6+
2) GNU Make 3+
3) A Verilog or VHDL simulator. Simulator support of cocotb documented [here](https://docs.cocotb.org/en/stable/simulator_support.html)

There is a quickstart guide [here](https://docs.cocotb.org/en/stable/quickstart.html). The installation, creating test, creating makefile, and running the test are explained in the quickstart guide.

In the example Verilog module, the up-down counter module is designed. The module outputs the counter value on each clock cycle according to direction (up, down, or idle). Direction input has 2-bit depth. Module counts for the direction value with "01" to up, "11" to down and the rest of the values counter stops at idle mode.

In the cocotb example Python script, 3 test scenarios were implemented and the module was verified.

The console screen after running Python script.
<img alt="test_console.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test_console.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">

1)Test starts with resetting the module, and the direction is defined as up and 50 clock cycle test ran. In each clock cycle the value of the counter is compared to actual values with an assertion.

<img alt="test1.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test1.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">

2)Direction changed to down counter.

<img alt="test2.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test2.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">

3)Direction changed up and down while the simulation running.

<img alt="test3.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test3.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">



