# verilog_basics
 This repository includes basic RTL sources written in Verilog-HDL
 
# n_bit_multiplier
 This module is a recursive implementation of the n-bit unsigned binary multiplier. The number of bits (n) of the multipliers can be managed by the BIT_DEPTH parameter. So, the module is reconfigurable according to the bit depth of multipliers before synthesis. Therefore, the utilization of the sources changes with the parameter BIT_DEPTH. 
 
 The module is called recursively inside the generate block. The first call starts with BIT_DEPTH configured in the parameters then it calls itself BIT_DEPTH/2 bit depth each time until BIT_DEPTH=2. Therefore, it all starts with 2-bit x 2-bit multiplication by using half adders. For example in an 8-bit multiplier, initially 4-bit multiplier is generated by 2-bit x 2-bit multipliers, and then an 8-bit multiplier is generated by using 4-bitx4-bit multipliers.
 
 <img width="426" alt="util32" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/440c7cbc-980e-4fbb-ac62-fb43201e29ea">

 
 <img width="425" alt="util16" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/472157b1-cd0c-4dd8-8b3e-fe5944b5fb3d">

 In the n_bit_multiplier/src/n_bit_mul.v, it can be seen that bit depth is defined as 32. Above you can see the utilization of the sources for the part xc7z020clg484-1.

<img width="1413" alt="sim32" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/200afa08-3354-4ad1-9397-1ca96b139159">

There is a multiplication simulation of the 32-bit configuration of the module. In the simulation, (2-4-8-16-32)-bit binary number multiplications are tested for two examples each bit depth.

To run the simulation with the Python script named [test.py](https://github.com/oktayogutcu/verilog_basics/blob/main/n_bit_multiplier/test.py), Icarus Verilog for MAC from this [link](https://formulae.brew.sh/formula/icarus-verilog) and for visualization GTKWave from this [link](https://gtkwave.sourceforge.net/.) has to be downloaded.

# 16_bit_multiplier

A non-recursive version of n_bit_multiplier is added for comparison of utilization and functionality.

<img width="371" alt="util" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/21569be1-b706-4a7d-8bc2-5adfacb11013">

It can be seen from the utilization result above, they have used the same amount of sources.

<img width="1237" alt="sim" src="https://github.com/oktayogutcu/verilog_basics/assets/46667326/6ebc45fb-70a6-47be-a9d9-22fa4dd75ed2">

Also, the module retains its functionality when comparing the recursive one.


# cocotb_example

Cocotb, which stands for Coroutine-based Co-simulation Testbench, is a Python library designed for validating hardware designs crafted in hardware description languages such as Verilog or VHDL. Cocotb seamlessly integrates with simulators, offering advanced capabilities for generating stimuli, validating results, and analyzing functional coverage. This enhances the overall hardware design verification procedure, making it more robust and efficient. Further explanation is [here](https://docs.cocotb.org/en/stable/index.html)

The latest version of Python cocotb library is recommended.
1) Python 3.6+
2) GNU Make 3+
3) A Verilog or VHDL simulator. Simulator support of cocotb documented [here](https://docs.cocotb.org/en/stable/simulator_support.html)

There is a quickstart guide [here](https://docs.cocotb.org/en/stable/quickstart.html). The installation, creating test, creating makefile, and running the test are explained in the quickstart guide.

In the example Verilog module, the up-down counter module is designed. The module outputs the counter value on each clock cycle according to direction (up, down, or idle). Direction input has 2-bit depth. Module counts for the direction value with "01" to up, "11" to down and the rest of the values counter stops at idle mode.

In the cocotb example Python script, 3 test scenarios were implemented and the module was verified.

The console screen after running Python script.
```
(base) Oktay-MBP:sim oktayogutcu$ make
rm -f results.xml
/Library/Developer/CommandLineTools/usr/bin/make -f Makefile results.xml
mkdir -p sim_build
/usr/local/bin/iverilog -o sim_build/sim.vvp -D COCOTB_SIM=1 -s updown_counter -f sim_build/cmds.f -g2012   /Users/oktayogutcu/Desktop/repo/rtl/verilog_basics/cocotb_exmaple/sim/../src/simple_design.v
rm -f results.xml
MODULE=simple_design_test TESTCASE= TOPLEVEL=updown_counter TOPLEVEL_LANG=verilog \
         /usr/local/bin/vvp -M /opt/anaconda3/lib/python3.9/site-packages/cocotb/libs -m libcocotbvpi_icarus   sim_build/sim.vvp 
     -.--ns INFO     gpi                                ..mbed/gpi_embed.cpp:78   in set_program_name_in_venv        Did not detect Python virtual environment. Using system-wide Python interpreter
     -.--ns INFO     gpi                                ../gpi/GpiCommon.cpp:101  in gpi_print_registered_impl       VPI registered
     0.00ns INFO     cocotb                             Running on Icarus Verilog version 12.0 (stable)
     0.00ns INFO     cocotb                             Running tests with cocotb v1.8.0 from /opt/anaconda3/lib/python3.9/site-packages/cocotb
     0.00ns INFO     cocotb                             Seeding Python random module with 1691180783
     0.00ns INFO     cocotb.regression                  Found test simple_design_test.up_count_test
     0.00ns INFO     cocotb.regression                  Found test simple_design_test.down_count_test
     0.00ns INFO     cocotb.regression                  Found test simple_design_test.updown_count_test
     0.00ns INFO     cocotb.regression                  running up_count_test (1/3)
VCD info: dumpfile dump.vcd opened for output.
Time scale of (updown_counter) is 1ns / 1ns
   540.00ns INFO     cocotb.regression                  up_count_test passed
   540.00ns INFO     cocotb.regression                  running down_count_test (2/3)
  1080.00ns INFO     cocotb.regression                  down_count_test passed
  1080.00ns INFO     cocotb.regression                  running updown_count_test (3/3)
  1620.00ns INFO     cocotb.regression                  updown_count_test passed
  1620.00ns INFO     cocotb.regression                  **********************************************************************************************
                                                        ** TEST                                  STATUS  SIM TIME (ns)  REAL TIME (s)  RATIO (ns/s) **
                                                        **********************************************************************************************
                                                        ** simple_design_test.up_count_test       PASS         540.00           0.01      61734.85  **
                                                        ** simple_design_test.down_count_test     PASS         540.00           0.01      68459.93  **
                                                        ** simple_design_test.updown_count_test   PASS         540.00           0.02      30378.48  **
                                                        **********************************************************************************************
                                                        ** TESTS=3 PASS=3 FAIL=0 SKIP=0                       1620.00           0.27       5978.40  **
                                                        **********************************************************************************************
```


1)Test starts with resetting the module, and the direction is defined as up and 50 clock cycle test ran. In each clock cycle the value of the counter is compared to actual values with an assertion.

```python
async def up_count_test(dut):
    
    dut.direction.value = 1
    
    cocotb.start_soon(clock_coroutine(dut.clk, 10))
    
    await reset_coroutine(dut.reset, 50)

    # run for 50 clock cycle
    for cnt in range(50): 
        await RisingEdge(dut.clk)
        v_count = dut.count.value
        mod_cnt = cnt % 16
        assert v_count.integer == mod_cnt, "counter result is incorrect: %s != %s" % (str(dut.count.value), mod_cnt)
```

<img alt="test1.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test1.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">

2)Direction changed to down counter.

```python
    dut.direction.value = -1
```

<img alt="test2.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test2.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">

3)Direction changed up and down while the simulation running.

```python
    # set direction signal for counting all directions
    cocotb.start_soon(updown_direction_coroutine(dut))
```

```python
# changing direction to up, down and the idle  
async def updown_direction_coroutine(dut):
    dut.direction.value = 0
    direction_counter = 0
    # await FallingEdge(dut.reset)
    while(True):
        if(direction_counter < 16):
            dut.direction.value = 1
        elif(direction_counter < 32):
            dut.direction.value = -1
        else:
            dut.direction.value = 0
            direction_counter = 0
        await RisingEdge(dut.clk)
        direction_counter += 1
```

<img alt="test3.png" src="https://github.com/oktayogutcu/verilog_basics/blob/main/cocotb_exmaple/sim/test3.png?raw=true" data-hpc="true" class="Box-sc-g0xbh4-0 kzRgrI">



